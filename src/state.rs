use std::cell::UnsafeCell;
use std::collections::hash_map::HashMap;
use std::collections::HashSet;
use std::ops::{Deref, DerefMut};
use std::sync::Arc;

use async_trait::async_trait;
use once_cell::sync::OnceCell;
use parking_lot::RwLock;

use crate::common::{Addr, Hash, Wei, U256};
use crate::core::{Code, PlainCode, WorldState, WorldStateR, WorldStateW};

/// Captures deltas (changes) made to an account in the world state. For all `Option` wrapped fields,
/// `None` means no change.
#[derive(Default, Clone)]
pub struct AccountStateDelta {
    pub state: HashMap<Hash, U256>,
    pub balance: Option<Wei>,
    pub nonce: Option<u64>,
    pub code: Option<Arc<dyn Code>>,
}

/// A log record generated by `log*` instruction in EVM.
#[derive(Clone)]
pub struct LogItem {
    pub contract: Addr,
    pub topics: Vec<Hash>,
    pub data: Hash,
    pub block_number: U256,
}

enum StateSource<'a> {
    Internal(Arc<MemStateRev<'a>>),
    External(Arc<dyn WorldStateR + 'a>),
}

impl<'a> Clone for StateSource<'a> {
    fn clone(&self) -> Self {
        use StateSource::*;
        match self {
            Internal(e) => Internal(e.clone()),
            External(e) => External(e.clone()),
        }
    }
}

// TODO: support suicided contracts
/// Captures all changes made to the world state.
#[derive(Clone)]
pub struct StateDelta {
    /// Account changes.
    pub accounts: HashMap<Addr, AccountStateDelta>,
    /// Log records added by the execution.
    pub logs: Vec<LogItem>,
    pub deleted_accounts: HashSet<Addr>,
}

/// A light-weight, in-memory revision of the world state. Use [MemStateShared], [MemStateMut] or
/// [MemStateAuto] because they are all based on this primitive and implements useful methods to
/// conveniently operate on in-memory world states.
///
/// A state revision is built by applying changes ([StateDelta]) upon another state revision or
/// other readable world state ([WorldStateR]) object (like a persistent storage system that
/// implements [WorldStateStore], or a middle layer cache). While all in-place changes could be
/// made to the same state revision (with mutable reference), the chaining mechanism allows
/// low-cost, in-memory snapshots so two different state revisions may share the same base
/// revision/world state source. The only caveat of using such versioned in-memory world state
/// implementation is that one should avoid generating new revisions for every small changes at
/// high frequency, because the state lookup time will increase linearly as the length of the
/// revision chain grows. But this is rarely the case for any practical, careful use. If frequent
/// reads have to be performed on a long revision chain, use `consolidate()` to merge the deltas
/// and squash the chain.
pub struct MemStateRev<'a> {
    parent: StateSource<'a>,
    delta: StateDelta,
}

macro_rules! rev_walk {
    ($self: expr, $func: expr, $exit: tt ($($tail: tt)*)) => {{
        let mut _s = None;
        let mut s = $self;
        loop {
            if let Some(t) = $func(s) {
                return t
            }
            match &s.parent {
                StateSource::Internal(p) => {
                    _s = Some(p.clone());
                    s = _s.as_ref().unwrap();
                },
                StateSource::External(p) => {
                    return p.$exit($($tail)*).await
                },
            }
        }
    }};
}

impl<'a> MemStateRev<'a> {
    /// Create a in-memory state revision object from the external state source that implements
    /// [WorldStateR].
    pub fn new(ext_src: Arc<dyn WorldStateR + 'a>) -> Self {
        MemStateRev {
            parent: StateSource::External(ext_src),
            delta: StateDelta {
                accounts: HashMap::new(),
                logs: Vec::new(),
                deleted_accounts: HashSet::new(),
            },
        }
    }

    /// Returns all state deltas (diffs) from the external source, useful to prepare the writes to
    /// a persistent storage. Returns `None` if the state revision has not been consolidated (the
    /// lookup chain is >0), in this case, one may use `consolidate` before this function to get
    /// the deltas.
    pub fn consolidated_delta(&self) -> Option<&StateDelta> {
        if let StateSource::External(_) = self.parent {
            return Some(&self.delta)
        }
        None
    }

    pub async fn get_state(&self, contract: &Addr, key: &Hash) -> U256 {
        if self.delta.deleted_accounts.contains(contract) {
            return U256::zero()
        }
        rev_walk!(
            self,
            |s: &Self| s
                .delta
                .accounts
                .get(contract)
                .and_then(|acc| acc.state.get(key))
                .copied(),
            get_state(contract, key)
        )
    }
    pub async fn get_balance(&self, account: &Addr) -> Wei {
        if self.delta.deleted_accounts.contains(account) {
            return Wei::zero().clone()
        }
        rev_walk!(
            self,
            |s: &MemStateRev| s
                .delta
                .accounts
                .get(account)
                .and_then(|acc| Some(acc.balance.as_ref()?.clone())),
            get_balance(account)
        )
    }
    pub async fn get_code(&self, contract: &Addr) -> Arc<dyn Code> {
        if self.delta.deleted_accounts.contains(contract) {
            return Arc::new(PlainCode::new(Vec::new().into()))
        }
        rev_walk!(
            self,
            |s: &MemStateRev| s
                .delta
                .accounts
                .get(contract)
                .and_then(|acc| Some(acc.code.as_ref()?.clone())),
            get_code(contract)
        )
    }
    pub async fn get_nonce(&self, contract: &Addr) -> u64 {
        if self.delta.deleted_accounts.contains(contract) {
            return 0
        }
        rev_walk!(
            self,
            |s: &MemStateRev| s
                .delta
                .accounts
                .get(contract)
                .and_then(|acc| acc.nonce),
            get_nonce(contract)
        )
    }
    pub async fn exist(&self, contract: &Addr) -> bool {
        if self.delta.deleted_accounts.contains(contract) {
            return false
        }
        rev_walk!(
            self,
            |s: &MemStateRev| if s.delta.accounts.contains_key(contract) {
                Some(true)
            } else {
                None
            },
            exist(contract)
        )
    }
    pub fn get_log(&self) -> &[LogItem] {
        &self.delta.logs
    }

    pub fn set_state(&mut self, contract: &Addr, key: &Hash, val: &U256) {
        self.get_account(contract).state.insert(key.clone(), *val);
    }
    pub fn set_balance(&mut self, contract: &Addr, balance: &Wei) {
        self.get_account(contract).balance = Some(balance.clone())
    }
    pub fn set_code(&mut self, contract: &Addr, code: &[u8]) {
        self.get_account(contract).code =
            Some(Arc::new(PlainCode::new(code.into())))
    }
    pub fn set_nonce(&mut self, contract: &Addr, nonce: u64) {
        self.get_account(contract).nonce = Some(nonce)
    }
    pub async fn create_account(&mut self, addr: &Addr) {
        let old_balance = self.get_balance(addr).await;
        self.delta.accounts.insert(
            addr.clone(),
            AccountStateDelta {
                state: HashMap::new(),
                balance: Some(Wei::zero().clone()),
                nonce: Some(0),
                code: Some(empty_code().clone()),
            },
        );
        if !old_balance.is_zero() {
            let acc = self.delta.accounts.get_mut(addr).unwrap();
            acc.balance = Some(old_balance);
        }
        self.delta.deleted_accounts.remove(addr);
    }
    pub fn delete_account(&mut self, addr: &Addr) {
        self.delta.deleted_accounts.insert(addr.clone());
        self.delta.accounts.remove(addr);
    }
    pub fn add_log(
        &mut self, contract: &Addr, topics: &[Hash], data: &[u8],
        block_number: &U256,
    ) {
        let contract = contract.clone();
        let topics = topics.to_vec();
        let data = Hash::from_slice(data);
        let block_number = *block_number;
        self.delta.logs.push(LogItem {
            contract,
            topics,
            data,
            block_number,
        });
    }

    /// Get the account only from the delta.
    fn get_account(&mut self, contract: &Addr) -> &mut AccountStateDelta {
        self.delta
            .accounts
            .entry(contract.clone())
            .or_insert_with(AccountStateDelta::default)
    }

    /// Squash the internal state revision chain so the lookup time is reduced (lookup length will
    /// be reduced to 0 if `max_back_steps` is `None`).
    pub fn consolidate(
        self: &Arc<Self>, max_back_steps: Option<usize>,
    ) -> Self {
        let mut revs = vec![self.clone()];
        // collect the revisions to be consolidated
        let (max_back_steps, inc) = (
            max_back_steps.unwrap_or(1),
            match max_back_steps {
                Some(_) => 1,
                None => 0,
            },
        );
        let mut s = self.clone();
        let mut i = 0;
        while i < max_back_steps {
            match &s.parent {
                StateSource::Internal(p) => {
                    revs.push(p.clone());
                    s = p.clone();
                }
                StateSource::External(_) => break,
            }
            i += inc
        }
        let parent = revs.last().unwrap().parent.clone();
        let mut accounts = HashMap::new();
        let mut logs = Vec::new();
        let mut deleted_accounts: HashSet<Addr> = HashSet::new();
        // apply the revisions which newer delta always overlay on an older version.
        for rev in revs.into_iter().rev() {
            for (addr, racc) in rev.delta.accounts.iter() {
                // Overlay newer accounts delta on deleted accounts.
                deleted_accounts.remove(addr);

                let mut acc = accounts
                    .entry(addr.clone())
                    .or_insert_with(AccountStateDelta::default);
                for (k, v) in racc.state.iter() {
                    acc.state.insert(k.clone(), *v);
                }
                if racc.balance.is_some() {
                    acc.balance = racc.balance.as_ref().cloned();
                }
                if racc.nonce.is_some() {
                    acc.nonce = racc.nonce;
                }
                if racc.code.is_some() {
                    acc.code = racc.code.as_ref().cloned();
                }
            }
            logs.extend_from_slice(&rev.delta.logs);
            deleted_accounts.extend(rev.delta.deleted_accounts.iter().cloned());
            // Overlay newer deleted accounts delta on accounts.
            for addr in &deleted_accounts {
                accounts.remove(addr);
            }
        }
        Self {
            parent,
            delta: StateDelta {
                accounts,
                logs,
                deleted_accounts,
            },
        }
    }

    /// Returns the lookup length of the underlying revision chain.
    pub fn depth(&self) -> usize {
        let mut d = 0;
        let mut s = self;
        while let StateSource::Internal(p) = &s.parent {
            s = p.as_ref();
            d += 1;
        }
        d
    }
}

/// A read-only in-memory world state object implemented on top of [MemStateRev]. It could be
/// cloned and shared among threads with negligible cost. It auto-dereferences to [MemStateRev].
/// The conversion from [MemStateMut] has negligible cost (no allocation).
pub struct MemStateShared<'a>(Arc<MemStateRev<'a>>);

impl<'a> Clone for MemStateShared<'a> {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}

impl<'a> MemStateShared<'a> {
    /// Create a shared in-memory world state from the external state source that implements
    /// [WorldStateR].
    pub fn new(ext_src: Arc<dyn WorldStateR + 'a>) -> Self {
        MemStateRev::new(ext_src).into()
    }

    /// Squash the internal state revision chain so the lookup time is reduced (lookup length will
    /// be reduced to 0 if `max_back_steps` is `None`).
    pub fn consolidate(&mut self, max_back_steps: Option<usize>) {
        if let StateSource::External(_) = self.parent {
            // if already consolidated, do nothing to optimize for the performance
            return
        }
        self.0 = Arc::new(self.0.consolidate(max_back_steps))
    }
}

impl<'a> From<MemStateRev<'a>> for MemStateShared<'a> {
    fn from(state: MemStateRev<'a>) -> Self {
        Self(Arc::new(state))
    }
}

impl<'a> From<MemStateMut<'a>> for MemStateShared<'a> {
    fn from(state: MemStateMut<'a>) -> Self {
        Self(state.0.into())
    }
}

/// A mutable in-memory world state object implemented on top of [MemStateRev]. It can be
/// constructed with some minimal allocation cost from [MemStateShared]. It auto-dereferences (mutably) to
/// [MemStateRev].
///
/// To avoid building up unnecessarily long lookup chain in the underlying [MemStateRev], one should
/// use the following principle to use [MemStateMut] and [MemStateShared]:
///
/// - When mutating the world state: create [MemStateMut] from [MemStateShared] and works on
///   [MemStateMut].
///
/// - When need to "fork" the world state to have an alternative version of it (but also keep the
///   original one): create [MemStateShared] from the current [MemStateMut].
///
/// Alternatively, use [MemStateAuto] where such action is taken automatically (by read/write
/// nature of the state methods).
pub struct MemStateMut<'a>(Box<MemStateRev<'a>>);

impl<'a> MemStateMut<'a> {
    /// Create a mutable in-memory world state from the external state source that implements
    /// [WorldStateR].
    pub fn new(ext_src: Arc<dyn WorldStateR + 'a>) -> Self {
        MemStateRev::new(ext_src).into()
    }

    /// Create a mutable in-memory world state from a shared state.
    pub fn from_shared(shared: &MemStateShared<'a>) -> Self {
        Self(Box::new(MemStateRev {
            parent: StateSource::Internal(shared.0.clone()),
            delta: StateDelta {
                accounts: HashMap::new(),
                logs: Vec::new(),
                deleted_accounts: HashSet::new(),
            },
        }))
    }
}

impl<'a> From<MemStateRev<'a>> for MemStateMut<'a> {
    fn from(state: MemStateRev<'a>) -> Self {
        Self(Box::new(state))
    }
}

impl<'a> Deref for MemStateShared<'a> {
    type Target = Arc<MemStateRev<'a>>;
    fn deref(&self) -> &Arc<MemStateRev<'a>> {
        &self.0
    }
}

impl<'a> Deref for MemStateMut<'a> {
    type Target = MemStateRev<'a>;
    fn deref(&self) -> &MemStateRev<'a> {
        &self.0
    }
}

impl<'a> DerefMut for MemStateMut<'a> {
    fn deref_mut(&mut self) -> &mut MemStateRev<'a> {
        &mut self.0
    }
}

enum MemStateInner<'a> {
    Const(MemStateShared<'a>),
    Mutable(MemStateMut<'a>),
}

/// Read/writable in-memory world state object that provides ergonomic use. It implements the full
/// [WorldState] trait so could be directly used in the interpreter (see [TxExecState::new](../core/enum.TxExecState.html#method.new)).
///
/// It automatically
/// switches (and creates) [MemStateShared] and [MemStateMut] internally in an on-demand fashion,
/// based on the state operation (writes turn a [MemStateShared] into [MemStateMut] and snapshots
/// turn [MemStateMut] into [MemStateShared]).
pub struct MemStateAuto<'a> {
    inner: UnsafeCell<MemStateInner<'a>>,
    lock: RwLock<()>,
}

impl<'a> From<MemStateMut<'a>> for MemStateAuto<'a> {
    fn from(state: MemStateMut<'a>) -> Self {
        Self {
            inner: UnsafeCell::new(MemStateInner::Mutable(state)),
            lock: RwLock::new(()),
        }
    }
}

impl<'a> From<MemStateShared<'a>> for MemStateAuto<'a> {
    fn from(state: MemStateShared<'a>) -> Self {
        Self {
            inner: UnsafeCell::new(MemStateInner::Const(state)),
            lock: RwLock::new(()),
        }
    }
}

impl<'a> MemStateAuto<'a> {
    /// Create an object from the external state source that implements [WorldStateR].
    pub fn new(ext_src: Arc<dyn WorldStateR + 'a>) -> Self {
        MemStateShared::new(ext_src).into()
    }

    fn convert_ref(&self) -> &MemStateRev<'a> {
        let s = unsafe { &*self.inner.get() };
        let _guard = self.lock.read();
        match s {
            MemStateInner::Const(state) => state,
            MemStateInner::Mutable(state) => state,
        }
    }
    fn convert_mut(&mut self) -> &mut MemStateRev<'a> {
        // The external user already guarantees that convert_mut invocations are mutually
        // exclusive and are mutually exclusive to convert_ref invocations.
        let s = self.inner.get_mut();
        if let MemStateInner::Const(state) = s {
            *s = MemStateInner::Mutable(MemStateMut::from_shared(state));
        }
        match s {
            MemStateInner::Const(_) => unreachable!(),
            MemStateInner::Mutable(state) => state,
        }
    }

    /// Returns a [MemStateShared] copy of the current state (this will automatically converts the
    /// internal [MemStateMut] to [MemStateShared] and effectively increase the lookup length by 1).
    pub fn to_shared(&self) -> MemStateShared<'a> {
        // The external user only guarantees snapshot() is mutually exclusive to convert_mut, so
        // we need a RwLock to ensure it is exclusive to convert_ref as well.
        unsafe {
            let s = &mut *self.inner.get();
            let _guard = self.lock.write();
            replace_with::replace_with_or_abort(s, |s| match s {
                MemStateInner::Mutable(state) => {
                    MemStateInner::Const(state.into())
                }
                c => c,
            });
            match s {
                MemStateInner::Const(state) => state.clone(),
                _ => unreachable!(),
            }
        }
    }
}

unsafe impl<'a> Sync for MemStateAuto<'a> {}

#[async_trait]
impl<'a> WorldStateR for MemStateAuto<'a> {
    async fn get_state(&self, contract: &Addr, key: &Hash) -> U256 {
        self.convert_ref().get_state(contract, key).await
    }
    async fn get_balance(&self, account: &Addr) -> Wei {
        self.convert_ref().get_balance(account).await
    }
    async fn get_code(&self, contract: &Addr) -> Arc<dyn Code> {
        self.convert_ref().get_code(contract).await
    }
    async fn get_nonce(&self, contract: &Addr) -> u64 {
        self.convert_ref().get_nonce(contract).await
    }
    async fn exist(&self, contract: &Addr) -> bool {
        self.convert_ref().exist(contract).await
    }
}

#[async_trait]
impl<'a> WorldStateW for MemStateAuto<'a> {
    fn set_state(&mut self, contract: &Addr, key: &Hash, val: &U256) {
        self.convert_mut().set_state(contract, key, val)
    }
    fn set_balance(&mut self, contract: &Addr, balance: &Wei) {
        self.convert_mut().set_balance(contract, balance)
    }
    fn set_code(&mut self, contract: &Addr, code: &[u8]) {
        self.convert_mut().set_code(contract, code)
    }
    fn set_nonce(&mut self, contract: &Addr, nonce: u64) {
        self.convert_mut().set_nonce(contract, nonce)
    }
    async fn create_account(&mut self, addr: &Addr) {
        self.convert_mut().create_account(addr).await
    }
    fn delete_account(&mut self, addr: &Addr) {
        self.convert_mut().delete_account(addr)
    }
    fn add_log(
        &mut self, contract: &Addr, topics: &[Hash], data: &[u8],
        block_number: &U256,
    ) {
        self.convert_mut()
            .add_log(contract, topics, data, block_number)
    }
}

impl<'a> WorldState for MemStateAuto<'a> {
    /// This will increase the internal lookup chain by 1. Use
    /// [MemStateShared::consolidate](struct.MemStateShared.html#method.consolidate) if the chain gets too long.
    fn snapshot(&self) -> Self {
        Self {
            inner: UnsafeCell::new(MemStateInner::Const(self.to_shared())),
            lock: RwLock::new(()),
        }
    }
    fn rollback(&mut self, mut state: Self) {
        std::mem::swap(self, &mut state);
    }
}

/// An empty state. Could be used as an external state source to test/try out `MemState*`.
pub struct EmptyState;

#[async_trait]
impl WorldStateR for EmptyState {
    async fn get_state(&self, _: &Addr, _: &Hash) -> U256 {
        U256::zero()
    }
    async fn get_balance(&self, _: &Addr) -> Wei {
        Wei::zero().clone()
    }
    async fn get_code(&self, _: &Addr) -> Arc<dyn Code> {
        empty_code()
    }
    async fn get_nonce(&self, _: &Addr) -> u64 {
        0
    }
    async fn exist(&self, _: &Addr) -> bool {
        false
    }
}

pub fn empty_code() -> Arc<dyn Code> {
    static V: OnceCell<Arc<dyn Code>> = OnceCell::new();
    V.get_or_init(|| Arc::new(PlainCode::new(Vec::new().into())))
        .clone()
}

/// A readable world state object with the awareness of some cryptographic account state root
/// (summary, i.e., a merkle root hash). `StateRoot` identifies the version of the account in the
/// world state.
#[async_trait]
pub trait AccountRootR<A>: WorldStateR {
    async fn get_account_root(&self, contract: &Addr) -> A;
}

/// Persistent storage abstraction. `StateRoot` identifies the version of the world state.
#[async_trait]
pub trait WorldStateStore {
    type Error;
    type StateRoot;
    type AccountRoot;
    fn read(&self, root: Option<&Self::StateRoot>) -> Arc<dyn WorldStateR>;
    /// Commit the changes to DB.
    /// * `root` - the old state root
    /// * `delta` - all changes applied upon the old world state (identified by `root`), could be
    /// partial as some fields of an account delta are `Option` type.
    /// * `reader` - a reader used in this RMW-style commit. Because `delta` may be partial to an
    /// account, some missing data (such as account state root) may be fetched by `reader`. A
    /// efficient reader could be provided by the cache layer that sits atop the DB in the read
    /// path. A native implementation could just use the same logic for `read` (need to return
    /// [AccountRootR] in place of [WorldStateR]) to supply a usable reader here (so it will
    /// directly read from the DB).
    async fn commit(
        &self, root: Option<&Self::StateRoot>, delta: &StateDelta,
        reader: &dyn AccountRootR<Self::AccountRoot>,
    ) -> Result<Self::StateRoot, Self::Error>;
}
